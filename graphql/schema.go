package graphql

import (
	"fmt"
	"sort"
	"strings"

	"github.com/pflow-xyz/go-pflow/petri"
)

// GenerateSchema creates a GraphQL SDL schema from a Petri net model.
// The schema includes:
// - Query type with instance and instances fields
// - Mutation type with create and transition fields
// - Instance type with marking and enabled transitions
// - Input types for each transition
func GenerateSchema(model *petri.PetriNet, name string) string {
	var sb strings.Builder

	sb.WriteString("# GraphQL schema generated from Petri net: ")
	sb.WriteString(name)
	sb.WriteString("\n\n")

	// Scalars
	sb.WriteString("scalar JSON\n")
	sb.WriteString("scalar Time\n\n")

	// Query type
	sb.WriteString("type Query {\n")
	sb.WriteString("  # Get instance by ID\n")
	sb.WriteString("  instance(id: ID!): Instance\n")
	sb.WriteString("\n")
	sb.WriteString("  # List instances with optional filtering\n")
	sb.WriteString("  instances(place: String, page: Int, perPage: Int): InstanceList!\n")
	sb.WriteString("}\n\n")

	// Mutation type
	sb.WriteString("type Mutation {\n")
	sb.WriteString("  # Create a new instance\n")
	sb.WriteString("  create: Instance!\n")
	sb.WriteString("\n")

	// Add mutation for each transition
	transitions := sortedTransitions(model)
	for _, t := range transitions {
		sb.WriteString(fmt.Sprintf("  # Fire transition: %s\n", t.Label))
		inputName := toPascalCase(t.Label) + "Input"
		sb.WriteString(fmt.Sprintf("  %s(input: %s!): TransitionResult!\n", t.Label, inputName))
		sb.WriteString("\n")
	}
	sb.WriteString("}\n\n")

	// Instance type
	sb.WriteString("# Petri net instance state\n")
	sb.WriteString("type Instance {\n")
	sb.WriteString("  id: ID!\n")
	sb.WriteString("  modelName: String!\n")
	sb.WriteString("  version: Int!\n")
	sb.WriteString("  marking: Marking!\n")
	sb.WriteString("  state: JSON\n")
	sb.WriteString("  enabledTransitions: [String!]!\n")
	sb.WriteString("}\n\n")

	// Marking type (place -> token count)
	sb.WriteString("# Token counts for each place\n")
	sb.WriteString("type Marking {\n")
	places := sortedPlaces(model)
	for _, p := range places {
		fieldName := toFieldName(p.Label)
		sb.WriteString(fmt.Sprintf("  %s: Int!\n", fieldName))
	}
	sb.WriteString("}\n\n")

	// TransitionResult type
	sb.WriteString("# Result of firing a transition\n")
	sb.WriteString("type TransitionResult {\n")
	sb.WriteString("  success: Boolean!\n")
	sb.WriteString("  instance: Instance\n")
	sb.WriteString("  error: String\n")
	sb.WriteString("}\n\n")

	// InstanceList type
	sb.WriteString("# Paginated list of instances\n")
	sb.WriteString("type InstanceList {\n")
	sb.WriteString("  items: [Instance!]!\n")
	sb.WriteString("  total: Int!\n")
	sb.WriteString("  page: Int!\n")
	sb.WriteString("}\n\n")

	// Input types for each transition
	sb.WriteString("# Input types for mutations\n\n")
	for _, t := range transitions {
		inputName := toPascalCase(t.Label) + "Input"
		sb.WriteString(fmt.Sprintf("input %s {\n", inputName))
		sb.WriteString("  instanceId: ID!\n")
		// TODO: Add binding fields based on transition definition
		sb.WriteString("}\n\n")
	}

	return sb.String()
}

// GenerateUnifiedSchema combines multiple model schemas into one.
// Each model's types are prefixed to avoid naming conflicts.
func GenerateUnifiedSchema(models map[string]*petri.PetriNet) string {
	var sb strings.Builder

	sb.WriteString("# Unified GraphQL Schema - Generated by go-pflow\n\n")
	sb.WriteString("scalar JSON\n")
	sb.WriteString("scalar Time\n\n")

	var allQueries []string
	var allMutations []string
	var allTypes []string

	// Sort model names for deterministic output
	names := make([]string, 0, len(models))
	for name := range models {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		model := models[name]
		prefix := toPascalCase(strings.ReplaceAll(name, "-", ""))
		lowerPrefix := strings.ToLower(prefix)

		// Query fields
		allQueries = append(allQueries,
			fmt.Sprintf("  %sInstance(id: ID!): %sInstance", lowerPrefix, prefix),
			fmt.Sprintf("  %sInstances(place: String, page: Int, perPage: Int): %sInstanceList!", lowerPrefix, prefix),
		)

		// Mutation fields
		allMutations = append(allMutations,
			fmt.Sprintf("  %s_create: %sInstance!", lowerPrefix, prefix),
		)

		transitions := sortedTransitions(model)
		for _, t := range transitions {
			inputName := prefix + toPascalCase(t.Label) + "Input"
			allMutations = append(allMutations,
				fmt.Sprintf("  %s_%s(input: %s!): %sTransitionResult!", lowerPrefix, t.Label, inputName, prefix),
			)
		}

		// Type definitions
		var typeBuf strings.Builder

		// Instance type
		typeBuf.WriteString(fmt.Sprintf("type %sInstance {\n", prefix))
		typeBuf.WriteString("  id: ID!\n")
		typeBuf.WriteString("  modelName: String!\n")
		typeBuf.WriteString("  version: Int!\n")
		typeBuf.WriteString(fmt.Sprintf("  marking: %sMarking!\n", prefix))
		typeBuf.WriteString("  state: JSON\n")
		typeBuf.WriteString("  enabledTransitions: [String!]!\n")
		typeBuf.WriteString("}")
		allTypes = append(allTypes, typeBuf.String())
		typeBuf.Reset()

		// Marking type
		typeBuf.WriteString(fmt.Sprintf("type %sMarking {\n", prefix))
		places := sortedPlaces(model)
		for _, p := range places {
			fieldName := toFieldName(p.Label)
			typeBuf.WriteString(fmt.Sprintf("  %s: Int!\n", fieldName))
		}
		typeBuf.WriteString("}")
		allTypes = append(allTypes, typeBuf.String())
		typeBuf.Reset()

		// TransitionResult type
		typeBuf.WriteString(fmt.Sprintf("type %sTransitionResult {\n", prefix))
		typeBuf.WriteString("  success: Boolean!\n")
		typeBuf.WriteString(fmt.Sprintf("  instance: %sInstance\n", prefix))
		typeBuf.WriteString("  error: String\n")
		typeBuf.WriteString("}")
		allTypes = append(allTypes, typeBuf.String())
		typeBuf.Reset()

		// InstanceList type
		typeBuf.WriteString(fmt.Sprintf("type %sInstanceList {\n", prefix))
		typeBuf.WriteString(fmt.Sprintf("  items: [%sInstance!]!\n", prefix))
		typeBuf.WriteString("  total: Int!\n")
		typeBuf.WriteString("  page: Int!\n")
		typeBuf.WriteString("}")
		allTypes = append(allTypes, typeBuf.String())
		typeBuf.Reset()

		// Input types
		for _, t := range transitions {
			inputName := prefix + toPascalCase(t.Label) + "Input"
			typeBuf.WriteString(fmt.Sprintf("input %s {\n", inputName))
			typeBuf.WriteString("  instanceId: ID!\n")
			typeBuf.WriteString("}")
			allTypes = append(allTypes, typeBuf.String())
			typeBuf.Reset()
		}
	}

	// Write Query type
	sb.WriteString("type Query {\n")
	for _, q := range allQueries {
		sb.WriteString(q + "\n")
	}
	sb.WriteString("}\n\n")

	// Write Mutation type
	sb.WriteString("type Mutation {\n")
	for _, m := range allMutations {
		sb.WriteString(m + "\n")
	}
	sb.WriteString("}\n\n")

	// Write all types
	for _, t := range allTypes {
		sb.WriteString(t + "\n\n")
	}

	return sb.String()
}

// sortedTransitions returns transitions sorted by label.
func sortedTransitions(model *petri.PetriNet) []*petri.Transition {
	transitions := make([]*petri.Transition, 0, len(model.Transitions))
	for _, t := range model.Transitions {
		transitions = append(transitions, t)
	}
	sort.Slice(transitions, func(i, j int) bool {
		return transitions[i].Label < transitions[j].Label
	})
	return transitions
}

// sortedPlaces returns places sorted by label.
func sortedPlaces(model *petri.PetriNet) []*petri.Place {
	places := make([]*petri.Place, 0, len(model.Places))
	for _, p := range model.Places {
		places = append(places, p)
	}
	sort.Slice(places, func(i, j int) bool {
		return places[i].Label < places[j].Label
	})
	return places
}

// toPascalCase converts a string to PascalCase.
func toPascalCase(s string) string {
	if s == "" {
		return ""
	}
	// Handle camelCase by capitalizing first letter
	return strings.ToUpper(s[:1]) + s[1:]
}

// toFieldName converts a place/transition label to a valid GraphQL field name.
func toFieldName(s string) string {
	// Replace invalid characters with underscore
	result := strings.Map(func(r rune) rune {
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') || (r >= '0' && r <= '9') || r == '_' {
			return r
		}
		return '_'
	}, s)

	// Ensure it doesn't start with a number
	if len(result) > 0 && result[0] >= '0' && result[0] <= '9' {
		result = "_" + result
	}

	return result
}

// CombineSchemas merges a base schema with external service schemas.
// External service schemas are namespaced with their service name prefix.
func CombineSchemas(baseSchema string, externals []ExternalService) string {
	var queries []string
	var mutations []string
	var types []string

	// Extract from base schema if present
	if baseSchema != "" {
		bq, bm, bt := extractSchemaComponents(baseSchema)
		queries = append(queries, bq...)
		mutations = append(mutations, bm...)
		types = append(types, bt...)
	}

	// Process each external service
	for _, svc := range externals {
		if svc.Schema == "" {
			continue
		}
		eq, em, et := extractAndNamespaceSchema(svc.Name, svc.Schema)
		queries = append(queries, eq...)
		mutations = append(mutations, em...)
		types = append(types, et...)
	}

	// Build combined schema
	var sb strings.Builder
	sb.WriteString("# Unified GraphQL Schema - Generated by go-pflow\n\n")
	sb.WriteString("scalar JSON\n")
	sb.WriteString("scalar Time\n\n")

	// Query type
	sb.WriteString("type Query {\n")
	for _, q := range queries {
		sb.WriteString("  " + q + "\n")
	}
	sb.WriteString("}\n\n")

	// Mutation type
	if len(mutations) > 0 {
		sb.WriteString("type Mutation {\n")
		for _, m := range mutations {
			sb.WriteString("  " + m + "\n")
		}
		sb.WriteString("}\n\n")
	}

	// Type definitions
	for _, t := range types {
		sb.WriteString(t + "\n\n")
	}

	return sb.String()
}

// extractSchemaComponents extracts queries, mutations, and types from a schema.
func extractSchemaComponents(schema string) (queries, mutations, types []string) {
	lines := strings.Split(schema, "\n")
	var currentSection string
	var typeBuffer strings.Builder
	var inType bool

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Skip scalars and comments
		if trimmed == "" || strings.HasPrefix(trimmed, "#") ||
			strings.HasPrefix(trimmed, "scalar ") {
			continue
		}

		// Detect section changes
		if strings.HasPrefix(trimmed, "type Query") {
			currentSection = "query"
			continue
		} else if strings.HasPrefix(trimmed, "type Mutation") {
			currentSection = "mutation"
			continue
		} else if (strings.HasPrefix(trimmed, "type ") || strings.HasPrefix(trimmed, "input ")) && strings.HasSuffix(trimmed, "{") {
			inType = true
			typeBuffer.Reset()
			typeBuffer.WriteString(line + "\n")
			currentSection = "type"
			continue
		} else if trimmed == "}" && inType {
			typeBuffer.WriteString(line)
			types = append(types, typeBuffer.String())
			inType = false
			typeBuffer.Reset()
			continue
		}

		if inType {
			typeBuffer.WriteString(line + "\n")
			continue
		}

		if trimmed == "}" {
			currentSection = ""
			continue
		}

		switch currentSection {
		case "query":
			queries = append(queries, strings.TrimSpace(line))
		case "mutation":
			mutations = append(mutations, strings.TrimSpace(line))
		}
	}

	return queries, mutations, types
}

// extractAndNamespaceSchema extracts and namespaces schema components for an external service.
func extractAndNamespaceSchema(serviceName, schema string) (queries, mutations, types []string) {
	prefix := toPascalCase(strings.ReplaceAll(serviceName, "-", ""))
	lowerPrefix := strings.ToLower(prefix)

	// Collect all defined types
	definedTypes := make(map[string]bool)
	for _, line := range strings.Split(schema, "\n") {
		trimmed := strings.TrimSpace(line)
		if strings.HasPrefix(trimmed, "type ") && strings.HasSuffix(trimmed, "{") {
			name := strings.TrimSpace(strings.TrimSuffix(strings.TrimPrefix(trimmed, "type "), "{"))
			if name != "Query" && name != "Mutation" {
				definedTypes[name] = true
			}
		} else if strings.HasPrefix(trimmed, "input ") && strings.HasSuffix(trimmed, "{") {
			name := strings.TrimSpace(strings.TrimSuffix(strings.TrimPrefix(trimmed, "input "), "{"))
			definedTypes[name] = true
		}
	}

	// Build rename map sorted by length descending
	renameMap := make(map[string]string)
	var sortedNames []string
	for typeName := range definedTypes {
		renameMap[typeName] = prefix + typeName
		sortedNames = append(sortedNames, typeName)
	}
	sort.Slice(sortedNames, func(i, j int) bool {
		return len(sortedNames[i]) > len(sortedNames[j])
	})

	// Parse and namespace
	lines := strings.Split(schema, "\n")
	var currentSection string
	var typeBuffer strings.Builder
	var inType bool

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		if strings.HasPrefix(trimmed, "type Query") {
			currentSection = "query"
			continue
		} else if strings.HasPrefix(trimmed, "type Mutation") {
			currentSection = "mutation"
			continue
		} else if (strings.HasPrefix(trimmed, "type ") || strings.HasPrefix(trimmed, "input ")) && strings.HasSuffix(trimmed, "{") {
			inType = true
			typeBuffer.Reset()
			typeBuffer.WriteString(line + "\n")
			currentSection = "type"
			continue
		} else if trimmed == "}" && inType {
			typeBuffer.WriteString(line)
			typeDef := applyRenames(typeBuffer.String(), sortedNames, renameMap)
			types = append(types, typeDef)
			inType = false
			typeBuffer.Reset()
			continue
		}

		if inType {
			typeBuffer.WriteString(line + "\n")
			continue
		}

		if trimmed == "" || strings.HasPrefix(trimmed, "#") || trimmed == "}" ||
			strings.HasPrefix(trimmed, "scalar ") {
			continue
		}

		switch currentSection {
		case "query":
			field := namespaceQueryField(trimmed, lowerPrefix, sortedNames, renameMap)
			queries = append(queries, field)
		case "mutation":
			field := namespaceMutationField(trimmed, lowerPrefix, sortedNames, renameMap)
			mutations = append(mutations, field)
		}
	}

	return queries, mutations, types
}

// applyRenames replaces type names using word boundaries.
func applyRenames(s string, sortedNames []string, renameMap map[string]string) string {
	result := s
	for _, name := range sortedNames {
		newName := renameMap[name]
		// Word boundary replacement
		result = replaceWordBoundary(result, name, newName)
	}
	return result
}

// replaceWordBoundary replaces occurrences of word at word boundaries.
func replaceWordBoundary(s, old, new string) string {
	var result strings.Builder
	i := 0
	for i < len(s) {
		// Look for the old string
		idx := strings.Index(s[i:], old)
		if idx == -1 {
			result.WriteString(s[i:])
			break
		}

		pos := i + idx
		// Check word boundaries
		leftOk := pos == 0 || !isWordChar(s[pos-1])
		rightOk := pos+len(old) >= len(s) || !isWordChar(s[pos+len(old)])

		if leftOk && rightOk {
			result.WriteString(s[i:pos])
			result.WriteString(new)
			i = pos + len(old)
		} else {
			result.WriteString(s[i : pos+len(old)])
			i = pos + len(old)
		}
	}
	return result.String()
}

func isWordChar(c byte) bool {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '_'
}

// namespaceQueryField prefixes a query field name.
func namespaceQueryField(field, lowerPrefix string, sortedNames []string, renameMap map[string]string) string {
	result := applyRenames(field, sortedNames, renameMap)

	// Prefix field names
	nameEnd := strings.IndexAny(field, "(:")
	if nameEnd > 0 {
		name := strings.TrimSpace(field[:nameEnd])
		if !strings.HasPrefix(name, lowerPrefix) {
			result = lowerPrefix + strings.ToUpper(name[:1]) + name[1:] + result[nameEnd:]
		}
	}
	return result
}

// namespaceMutationField transforms mutation names.
func namespaceMutationField(field, lowerPrefix string, sortedNames []string, renameMap map[string]string) string {
	result := applyRenames(field, sortedNames, renameMap)

	trimmed := strings.TrimSpace(result)
	nameEnd := strings.IndexAny(trimmed, "(:")
	if nameEnd > 0 {
		name := strings.TrimSpace(trimmed[:nameEnd])
		sep := trimmed[nameEnd]
		rest := trimmed[nameEnd:]

		if strings.HasPrefix(name, "create") && sep == ':' {
			result = lowerPrefix + "_create" + rest
		} else {
			result = lowerPrefix + "_" + name + rest
		}
	}
	return result
}
