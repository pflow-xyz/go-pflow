package petrigen

// stateTemplate generates the Petri net state definitions.
const stateTemplate = `// Code generated by go-pflow petrigen. DO NOT EDIT.
package {{.PackageName}}

import (
	"fmt"
	"math/big"

	"github.com/consensys/gnark-crypto/ecc/bn254/fr"
	"github.com/consensys/gnark-crypto/ecc/bn254/fr/mimc"
)

// NumPlaces is the number of places in the Petri net.
const NumPlaces = {{.NumPlaces}}

// NumTransitions is the number of transitions in the Petri net.
const NumTransitions = {{.NumTransitions}}

// Place indices.
const (
{{.PlaceConstNames}}
)

// PlaceNames maps place indices to their IDs.
var PlaceNames = [NumPlaces]string{ {{.PlaceNamesLiteral}} }

// Transition indices.
const (
{{.TransitionConstNames}}
)

// TransitionNames maps transition indices to their IDs.
var TransitionNames = [NumTransitions]string{ {{.TransitionNamesLiteral}} }

// ArcDef represents input and output arcs for a transition.
type ArcDef struct {
	Inputs  []int // places consumed
	Outputs []int // places produced
}

// Topology defines the Petri net arcs.
var Topology = [NumTransitions]ArcDef{
{{.TopologyLiteral}}
}

// Marking represents the token counts for all places.
type Marking [NumPlaces]uint8

// InitialMarking returns the initial marking from the model.
func InitialMarking() Marking {
	return Marking{
{{.InitialMarkingLiteral}}
	}
}

// ComputeMarkingRoot computes a MiMC hash of the full marking.
func ComputeMarkingRoot(m Marking) *big.Int {
	h := mimc.NewMiMC()
	for _, tokens := range m {
		var elem fr.Element
		elem.SetUint64(uint64(tokens))
		b := elem.Bytes()
		h.Write(b[:])
	}
	sum := h.Sum(nil)
	return new(big.Int).SetBytes(sum)
}

// IsEnabled checks if a transition can fire with the current marking.
func IsEnabled(m Marking, t int) bool {
	if t < 0 || t >= NumTransitions {
		return false
	}
	for _, p := range Topology[t].Inputs {
		if m[p] < 1 {
			return false
		}
	}
	return true
}

// Fire applies a transition and returns the new marking.
func Fire(m Marking, t int) (Marking, error) {
	if !IsEnabled(m, t) {
		return m, fmt.Errorf("transition %s is not enabled", TransitionNames[t])
	}

	newM := m
	for _, p := range Topology[t].Inputs {
		newM[p]--
	}
	for _, p := range Topology[t].Outputs {
		newM[p]++
	}
	return newM, nil
}

// EnabledTransitions returns all transitions that can fire.
func EnabledTransitions(m Marking) []int {
	var enabled []int
	for t := 0; t < NumTransitions; t++ {
		if IsEnabled(m, t) {
			enabled = append(enabled, t)
		}
	}
	return enabled
}
`

// circuitsTemplate generates the gnark ZK circuits.
const circuitsTemplate = `// Code generated by go-pflow petrigen. DO NOT EDIT.
package {{.PackageName}}

import (
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/std/hash/mimc"
)

// PetriTransitionCircuit proves that firing a transition on the Petri net is valid.
//
// Public inputs:
//   - PreStateRoot:  MiMC hash of marking before transition
//   - PostStateRoot: MiMC hash of marking after transition
//   - Transition:    which transition fired (0 to NumTransitions-1)
//
// Private inputs:
//   - PreMarking:  token counts for all places before firing
//   - PostMarking: token counts for all places after firing
type PetriTransitionCircuit struct {
	// Public
	PreStateRoot  frontend.Variable ` + "`gnark:\",public\"`" + `
	PostStateRoot frontend.Variable ` + "`gnark:\",public\"`" + `
	Transition    frontend.Variable ` + "`gnark:\",public\"`" + `

	// Private
	PreMarking  [NumPlaces]frontend.Variable
	PostMarking [NumPlaces]frontend.Variable
}

// Define declares the constraints for valid Petri net transition firing.
func (c *PetriTransitionCircuit) Define(api frontend.API) error {
	// 1. Verify pre-state root matches the private marking
	preRoot := petriMimcHash(api, c.PreMarking[:])
	api.AssertIsEqual(preRoot, c.PreStateRoot)

	// 2. Verify post-state root matches the private marking
	postRoot := petriMimcHash(api, c.PostMarking[:])
	api.AssertIsEqual(postRoot, c.PostStateRoot)

	// 3. Compute expected deltas based on which transition fired
	var deltas [NumPlaces]frontend.Variable
	for p := 0; p < NumPlaces; p++ {
		deltas[p] = frontend.Variable(0)
	}

	// For each transition, conditionally add its effect
	for t := 0; t < NumTransitions; t++ {
		isThis := api.IsZero(api.Sub(c.Transition, t))

		// Subtract 1 from input places
		for _, p := range Topology[t].Inputs {
			deltas[p] = api.Sub(deltas[p], isThis)
		}
		// Add 1 to output places
		for _, p := range Topology[t].Outputs {
			deltas[p] = api.Add(deltas[p], isThis)
		}
	}

	// 4. Verify the marking change matches the computed deltas
	for p := 0; p < NumPlaces; p++ {
		expected := api.Add(c.PreMarking[p], deltas[p])
		api.AssertIsEqual(c.PostMarking[p], expected)
	}

	// 5. Verify enabledness: input places must have >= 1 token
	for p := 0; p < NumPlaces; p++ {
		isInput := frontend.Variable(0)
		for t := 0; t < NumTransitions; t++ {
			isThis := api.IsZero(api.Sub(c.Transition, t))
			for _, inp := range Topology[t].Inputs {
				if inp == p {
					isInput = api.Add(isInput, isThis)
				}
			}
		}
		// pre[p] - isInput must be non-negative
		diff := api.Sub(c.PreMarking[p], isInput)
		api.ToBinary(diff, 8)
	}

	return nil
}

// petriMimcHash computes MiMC hash of marking values.
func petriMimcHash(api frontend.API, values []frontend.Variable) frontend.Variable {
	h, _ := mimc.NewMiMC(api)
	for _, v := range values {
		h.Write(v)
	}
	return h.Sum()
}

// PetriReadCircuit proves that a specific place has tokens.
// Use this to verify any place condition (e.g., win states, completion, etc.).
type PetriReadCircuit struct {
	// Public
	StateRoot   frontend.Variable ` + "`gnark:\",public\"`" + `
	TargetPlace frontend.Variable ` + "`gnark:\",public\"`" + ` // place index to check

	// Private
	Marking [NumPlaces]frontend.Variable
}

// Define declares the constraints for place verification.
func (c *PetriReadCircuit) Define(api frontend.API) error {
	// 1. Verify state root matches the private marking
	root := petriMimcHash(api, c.Marking[:])
	api.AssertIsEqual(root, c.StateRoot)

	// 2. Verify the target place has at least 1 token
	tokens := frontend.Variable(0)
	for p := 0; p < NumPlaces; p++ {
		isTarget := api.IsZero(api.Sub(c.TargetPlace, p))
		tokens = api.Add(tokens, api.Mul(c.Marking[p], isTarget))
	}

	// tokens >= 1
	api.ToBinary(api.Sub(tokens, 1), 8)

	return nil
}
`

// gameTemplate generates the game/witness management code.
const gameTemplate = `// Code generated by go-pflow petrigen. DO NOT EDIT.
package {{.PackageName}}

import (
	"fmt"
	"math/big"
)

// PetriGame tracks the full Petri net state for ZK proof generation.
type PetriGame struct {
	Marking Marking
	Roots   []*big.Int // state root after each transition
}

// NewPetriGame creates a new game with the initial marking.
func NewPetriGame() *PetriGame {
	m := InitialMarking()
	root := ComputeMarkingRoot(m)
	return &PetriGame{
		Marking: m,
		Roots:   []*big.Int{root},
	}
}

// CurrentRoot returns the current marking's state root.
func (g *PetriGame) CurrentRoot() *big.Int {
	return g.Roots[len(g.Roots)-1]
}

// PetriTransitionWitness contains all values needed to generate a ZK proof.
type PetriTransitionWitness struct {
	PreStateRoot  *big.Int
	PostStateRoot *big.Int
	Transition    int
	PreMarking    Marking
	PostMarking   Marking
}

// FireTransition fires a transition and returns the witness for proof generation.
func (g *PetriGame) FireTransition(t int) (*PetriTransitionWitness, error) {
	if t < 0 || t >= NumTransitions {
		return nil, fmt.Errorf("invalid transition index: %d", t)
	}

	preMarking := g.Marking
	preRoot := g.CurrentRoot()

	newMarking, err := Fire(g.Marking, t)
	if err != nil {
		return nil, fmt.Errorf("transition %s failed: %w", TransitionNames[t], err)
	}

	postRoot := ComputeMarkingRoot(newMarking)

	witness := &PetriTransitionWitness{
		PreStateRoot:  preRoot,
		PostStateRoot: postRoot,
		Transition:    t,
		PreMarking:    preMarking,
		PostMarking:   newMarking,
	}

	g.Marking = newMarking
	g.Roots = append(g.Roots, postRoot)

	return witness, nil
}

// PetriPlaceWitness contains values for proving a place has tokens.
type PetriPlaceWitness struct {
	StateRoot   *big.Int
	TargetPlace int
	Marking     Marking
}

// GetPlaceWitness returns a witness for proving a place has tokens.
// Returns nil if the place has no tokens.
func (g *PetriGame) GetPlaceWitness(place int) *PetriPlaceWitness {
	if place < 0 || place >= NumPlaces {
		return nil
	}
	if g.Marking[place] == 0 {
		return nil
	}
	return &PetriPlaceWitness{
		StateRoot:   g.CurrentRoot(),
		TargetPlace: place,
		Marking:     g.Marking,
	}
}

// ToPetriTransitionAssignment converts a witness to a circuit assignment.
func (w *PetriTransitionWitness) ToPetriTransitionAssignment() *PetriTransitionCircuit {
	c := &PetriTransitionCircuit{
		PreStateRoot:  w.PreStateRoot,
		PostStateRoot: w.PostStateRoot,
		Transition:    w.Transition,
	}
	for i := 0; i < NumPlaces; i++ {
		c.PreMarking[i] = int(w.PreMarking[i])
		c.PostMarking[i] = int(w.PostMarking[i])
	}
	return c
}

// ToPetriReadAssignment converts a witness to a circuit assignment.
func (w *PetriPlaceWitness) ToPetriReadAssignment() *PetriReadCircuit {
	c := &PetriReadCircuit{
		StateRoot:   w.StateRoot,
		TargetPlace: w.TargetPlace,
	}
	for i := 0; i < NumPlaces; i++ {
		c.Marking[i] = int(w.Marking[i])
	}
	return c
}

// String returns a human-readable representation of the marking.
func (m Marking) String() string {
	var s string
	for i := 0; i < NumPlaces; i++ {
		if m[i] > 0 {
			s += fmt.Sprintf("%s: %d\n", PlaceNames[i], m[i])
		}
	}
	if s == "" {
		s = "(empty marking)\n"
	}
	return s
}
`

// testTemplate generates tests for the circuits.
const testTemplate = `// Code generated by go-pflow petrigen. DO NOT EDIT.
package {{.PackageName}}

import (
	"testing"

	"github.com/consensys/gnark-crypto/ecc"
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/frontend/cs/r1cs"
	"github.com/consensys/gnark/test"
)

func TestPetriTransitionCircuit_Compiles(t *testing.T) {
	_, err := frontend.Compile(ecc.BN254.ScalarField(), r1cs.NewBuilder, &PetriTransitionCircuit{})
	if err != nil {
		t.Fatalf("PetriTransitionCircuit compilation failed: %v", err)
	}
}

func TestPetriReadCircuit_Compiles(t *testing.T) {
	_, err := frontend.Compile(ecc.BN254.ScalarField(), r1cs.NewBuilder, &PetriReadCircuit{})
	if err != nil {
		t.Fatalf("PetriReadCircuit compilation failed: %v", err)
	}
}

func TestPetriTransitionCircuit_ValidTransition(t *testing.T) {
	game := NewPetriGame()

	// Find first enabled transition
	enabled := EnabledTransitions(game.Marking)
	if len(enabled) == 0 {
		t.Skip("no enabled transitions in initial state")
	}

	witness, err := game.FireTransition(enabled[0])
	if err != nil {
		t.Fatal(err)
	}

	assignment := witness.ToPetriTransitionAssignment()
	assert := test.NewAssert(t)
	assert.ProverSucceeded(&PetriTransitionCircuit{}, assignment, test.WithCurves(ecc.BN254))
}

func TestPetriTransitionCircuit_InvalidTransition(t *testing.T) {
	game := NewPetriGame()

	// Find a disabled transition
	var disabled int = -1
	for tr := 0; tr < NumTransitions; tr++ {
		if !IsEnabled(game.Marking, tr) {
			disabled = tr
			break
		}
	}
	if disabled == -1 {
		t.Skip("all transitions are enabled")
	}

	// Trying to fire disabled transition should fail
	_, err := game.FireTransition(disabled)
	if err == nil {
		t.Fatal("expected error for disabled transition")
	}
}

func TestMarkingRootConsistency(t *testing.T) {
	m1 := InitialMarking()
	r1 := ComputeMarkingRoot(m1)
	r2 := ComputeMarkingRoot(m1)

	if r1.Cmp(r2) != 0 {
		t.Fatal("marking root not deterministic")
	}
}

func TestInitialMarking(t *testing.T) {
	m := InitialMarking()

	// Verify some places have expected initial values
	nonZero := 0
	for i := 0; i < NumPlaces; i++ {
		if m[i] > 0 {
			nonZero++
		}
	}

	if nonZero == 0 {
		t.Log("Warning: initial marking has no tokens")
	}
}

func TestTopologyConsistency(t *testing.T) {
	// Verify all arc references are valid place indices
	for tr := 0; tr < NumTransitions; tr++ {
		for _, p := range Topology[tr].Inputs {
			if p < 0 || p >= NumPlaces {
				t.Errorf("transition %s has invalid input place index %d", TransitionNames[tr], p)
			}
		}
		for _, p := range Topology[tr].Outputs {
			if p < 0 || p >= NumPlaces {
				t.Errorf("transition %s has invalid output place index %d", TransitionNames[tr], p)
			}
		}
	}
}
`
