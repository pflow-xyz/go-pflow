package zkcompile

import (
	"fmt"
	"strings"
)

// GnarkCodegen generates gnark circuit code from our constraint IR.
// Output is Go source code that can be compiled with gnark.
type GnarkCodegen struct {
	packageName string
	circuitName string
}

// NewGnarkCodegen creates a new gnark code generator.
func NewGnarkCodegen(packageName, circuitName string) *GnarkCodegen {
	return &GnarkCodegen{
		packageName: packageName,
		circuitName: circuitName,
	}
}

// GenerateCircuit generates a complete gnark circuit from compilation results.
func (g *GnarkCodegen) GenerateCircuit(
	guardResult *CompileResult,
	merkleProofs []*MerkleProof,
	merkleConstraints []*Constraint,
	invariantConstraints []*Constraint,
) string {
	var sb strings.Builder

	// Collect all constraints
	allConstraints := append([]*Constraint{}, guardResult.Constraints...)
	allConstraints = append(allConstraints, merkleConstraints...)
	allConstraints = append(allConstraints, invariantConstraints...)

	// Generate package and imports
	sb.WriteString(g.generateHeader())
	sb.WriteString("\n\n")

	// Generate circuit struct
	sb.WriteString(g.generateCircuitStruct(guardResult.Witnesses, merkleProofs))
	sb.WriteString("\n\n")

	// Generate Define method
	sb.WriteString(g.generateDefineMethod(allConstraints))

	return sb.String()
}

// generateHeader generates package declaration and imports.
func (g *GnarkCodegen) generateHeader() string {
	return fmt.Sprintf(`// Code generated by go-pflow zkcompile. DO NOT EDIT.
package %s

import (
	"github.com/consensys/gnark/frontend"
	"github.com/consensys/gnark/std/hash/mimc"
)

// mimcHash computes MiMC hash of two inputs
func mimcHash(api frontend.API, left, right frontend.Variable) frontend.Variable {
	h, _ := mimc.NewMiMC(api)
	h.Write(left)
	h.Write(right)
	return h.Sum()
}`, g.packageName)
}

// generateCircuitStruct generates the circuit struct with all witness variables.
func (g *GnarkCodegen) generateCircuitStruct(witnesses *WitnessTable, proofs []*MerkleProof) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("// %s is the ZK circuit for state transition verification.\n", g.circuitName))
	sb.WriteString(fmt.Sprintf("type %s struct {\n", g.circuitName))

	// Public inputs
	sb.WriteString("\t// Public inputs\n")
	sb.WriteString("\tPreStateRoot  frontend.Variable `gnark:\",public\"`\n")
	sb.WriteString("\tPostStateRoot frontend.Variable `gnark:\",public\"`\n")
	sb.WriteString("\n")

	// Transaction bindings (public)
	sb.WriteString("\t// Transaction bindings (public)\n")
	for name, w := range witnesses.Variables {
		if w.Source == FromBinding {
			sb.WriteString(fmt.Sprintf("\t%s frontend.Variable `gnark:\",public\"` // %s\n",
				toGoName(name), w.String()))
		}
	}
	sb.WriteString("\n")

	// State values (private - proven via Merkle proofs)
	sb.WriteString("\t// State values (private, proven via Merkle proofs)\n")
	for name, w := range witnesses.Variables {
		if w.Source == FromState {
			sb.WriteString(fmt.Sprintf("\t%s frontend.Variable // %s\n",
				toGoName(name), w.String()))
		}
	}
	sb.WriteString("\n")

	// Merkle proof paths
	sb.WriteString("\t// Merkle proof paths\n")
	for i, proof := range proofs {
		sb.WriteString(fmt.Sprintf("\t// Proof %d: %s\n", i, proof.Value))
		for j, elem := range proof.PathElements {
			sb.WriteString(fmt.Sprintf("\t%s frontend.Variable\n", toGoName(elem)))
			sb.WriteString(fmt.Sprintf("\t%s frontend.Variable\n", toGoName(proof.PathIndices[j])))
		}
		sb.WriteString("\n")
	}

	// Computed witnesses (private)
	sb.WriteString("\t// Computed witnesses (private)\n")
	for name, w := range witnesses.Variables {
		if w.Source == Computed {
			sb.WriteString(fmt.Sprintf("\t%s frontend.Variable\n", toGoName(name)))
		}
	}

	sb.WriteString("}\n")
	return sb.String()
}

// generateDefineMethod generates the Define() method with all constraints.
func (g *GnarkCodegen) generateDefineMethod(constraints []*Constraint) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("// Define declares the circuit constraints.\n"))
	sb.WriteString(fmt.Sprintf("func (c *%s) Define(api frontend.API) error {\n", g.circuitName))

	// Generate constraint implementations
	for i, constraint := range constraints {
		sb.WriteString(fmt.Sprintf("\t// Constraint %d: %s\n", i+1, constraint.Tag))
		sb.WriteString(g.generateConstraint(constraint))
		sb.WriteString("\n")
	}

	sb.WriteString("\treturn nil\n")
	sb.WriteString("}\n")

	return sb.String()
}

// generateConstraint generates gnark code for a single constraint.
func (g *GnarkCodegen) generateConstraint(c *Constraint) string {
	switch c.Type {
	case Equal:
		left := g.generateExpr(c.Left)
		right := g.generateExpr(c.Right)
		return fmt.Sprintf("\tapi.AssertIsEqual(%s, %s)\n", left, right)

	case LessOrEqual:
		// Range check: prove value is non-negative
		// In gnark, we use api.ToBinary to decompose and verify range
		value := g.generateExpr(c.Right)
		return fmt.Sprintf("\tapi.AssertIsLessOrEqual(%s, frontend.Variable(1<<64-1)) // range check\n", value)

	case Boolean:
		value := g.generateExpr(c.Left)
		return fmt.Sprintf("\tapi.AssertIsBoolean(%s)\n", value)

	case Poseidon:
		out := g.generateExpr(c.Out)
		left := g.generateExpr(c.Left)
		right := g.generateExpr(c.Right)
		return fmt.Sprintf("\tapi.AssertIsEqual(%s, mimcHash(api, %s, %s))\n",
			out, left, right)

	default:
		return fmt.Sprintf("\t// TODO: unsupported constraint type: %v\n", c.Type)
	}
}

// generateExpr generates gnark code for an expression.
func (g *GnarkCodegen) generateExpr(e *Expr) string {
	if e == nil {
		return "nil"
	}

	switch e.Type {
	case ExprVar:
		return fmt.Sprintf("c.%s", toGoName(e.Variable))

	case ExprConst:
		return fmt.Sprintf("frontend.Variable(%s)", e.Value)

	case ExprAdd:
		left := g.generateExpr(e.Left)
		right := g.generateExpr(e.Right)
		return fmt.Sprintf("api.Add(%s, %s)", left, right)

	case ExprSub:
		left := g.generateExpr(e.Left)
		right := g.generateExpr(e.Right)
		return fmt.Sprintf("api.Sub(%s, %s)", left, right)

	case ExprMul:
		left := g.generateExpr(e.Left)
		right := g.generateExpr(e.Right)
		return fmt.Sprintf("api.Mul(%s, %s)", left, right)

	case ExprDiv:
		left := g.generateExpr(e.Left)
		right := g.generateExpr(e.Right)
		return fmt.Sprintf("api.Div(%s, %s)", left, right)

	case ExprNeg:
		operand := g.generateExpr(e.Operand)
		return fmt.Sprintf("api.Neg(%s)", operand)

	default:
		return fmt.Sprintf("/* unknown expr type: %v */", e.Type)
	}
}

// toGoName converts a witness name to a valid Go identifier.
// Converts snake_case to PascalCase and handles special characters.
func toGoName(name string) string {
	// Handle const_ prefix
	name = strings.TrimPrefix(name, "const_")

	// Split by underscore and capitalize each part
	parts := strings.Split(name, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}

	result := strings.Join(parts, "")

	// Handle hex addresses - prefix with Addr
	if strings.HasPrefix(result, "0x") || strings.HasPrefix(result, "0X") {
		result = "Addr" + result[2:]
	}

	return result
}

// CircuitStats provides statistics about a generated circuit.
type CircuitStats struct {
	TotalConstraints  int
	EqualityCount     int
	RangeCheckCount   int
	BooleanCount      int
	PoseidonHashCount int
	WitnessCount      int
	PublicInputCount  int
	PrivateInputCount int
}

// ComputeStats calculates statistics for a circuit.
func ComputeStats(
	guardResult *CompileResult,
	merkleConstraints []*Constraint,
	invariantConstraints []*Constraint,
) *CircuitStats {
	stats := &CircuitStats{}

	allConstraints := append([]*Constraint{}, guardResult.Constraints...)
	allConstraints = append(allConstraints, merkleConstraints...)
	allConstraints = append(allConstraints, invariantConstraints...)

	stats.TotalConstraints = len(allConstraints)

	for _, c := range allConstraints {
		switch c.Type {
		case Equal:
			stats.EqualityCount++
		case LessOrEqual:
			stats.RangeCheckCount++
		case Boolean:
			stats.BooleanCount++
		case Poseidon:
			stats.PoseidonHashCount++
		}
	}

	for _, w := range guardResult.Witnesses.Variables {
		stats.WitnessCount++
		if w.Source == FromBinding {
			stats.PublicInputCount++
		} else {
			stats.PrivateInputCount++
		}
	}

	return stats
}

func (s *CircuitStats) String() string {
	return fmt.Sprintf(`Circuit Statistics:
  Total constraints: %d
    - Equality:      %d
    - Range checks:  %d
    - Boolean:       %d
    - Poseidon hash: %d
  Witnesses: %d
    - Public:        %d
    - Private:       %d`,
		s.TotalConstraints,
		s.EqualityCount,
		s.RangeCheckCount,
		s.BooleanCount,
		s.PoseidonHashCount,
		s.WitnessCount,
		s.PublicInputCount,
		s.PrivateInputCount)
}
